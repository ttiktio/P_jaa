<!-- index.html (Dark Mode + Mobile + Random + Global Dictionary + Hints) -->
<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Wordle - เกมทายคำ (A2–C1 + Random)</title>
  <style>
    :root{
      --bg:#0b0f14; --bg-grad-1:#0b0f14; --bg-grad-2:#0f1620;
      --panel:#111826; --panel-2:#0e1520; --border:#1f2937;
      --text:#e5e7eb; --muted:#9aa4b2; --accent-1:#3b82f6; --accent-2:#8b5cf6;
      --tile:56px; --gap:8px; --container-w:min(520px,92vw); --k-gap:6px;
      --correct:#22c55e; --present:#eab308; --absent:#64748b;
      --tile-border:#334155; --tile-bg:#0f172a; --key-bg:#1f2937; --key-bg-hover:#273244; --key-text:#e5e7eb;
      --hint-bg: #0b2538; --hint-border: #3b82f6;
    }
    *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html{-webkit-text-size-adjust:100%}
    html,body{height:100%}
    body{
      font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(59,130,246,.15), transparent 60%),
        radial-gradient(1200px 700px at 85% 110%, rgba(139,92,246,.13), transparent 60%),
        linear-gradient(135deg, var(--bg-grad-1), var(--bg-grad-2));
      min-height:100dvh; display:flex; justify-content:center; align-items:center;
      padding:20px; padding-bottom:calc(20px + env(safe-area-inset-bottom));
      color:var(--text); touch-action:manipulation;
    }
    .container{
      width:var(--container-w); background:var(--panel); border-radius:18px;
      box-shadow:0 20px 60px rgba(0,0,0,.45), 0 0 0 1px rgba(255,255,255,.04) inset;
      display:flex; flex-direction:column; max-height:calc(100dvh - 40px); overflow:hidden;
      border:1px solid var(--border);
    }
    header{
      padding:14px 16px; border-bottom:1px solid var(--border); background:linear-gradient(180deg,#131c2b,#101723);
      display:flex; align-items:center; gap:10px; justify-content:space-between;
    }
    h1{font-size:1.2rem; font-weight:800; letter-spacing:.3px; color:#f3f4f6}
    .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    label{font-size:14px;color:var(--muted);font-weight:700}
    select,button{
      border:1px solid var(--border); border-radius:10px; padding:10px 12px; background:var(--panel-2);
      font-weight:700; cursor:pointer; color:var(--text); font-size:16px; outline:none;
    }
    select:focus,button:focus{ box-shadow:0 0 0 2px rgba(59,130,246,.35) }
    button.primary{ background:linear-gradient(135deg, rgba(59,130,246,.9), rgba(139,92,246,.9)); color:#fff; border:none; }
    .subtitle{ padding:8px 16px; background:#0f1623; color:var(--muted); font-size:.95rem; border-bottom:1px solid var(--border) }
    .content{ display:flex; flex-direction:column; gap:12px; padding:14px 12px; overflow:auto; background:linear-gradient(180deg,#0e1520 0%,#0b111a 100%); }
    .game-board{display:flex; flex-direction:column; gap:var(--gap); align-items:center}
    .row{display:flex; gap:var(--gap); justify-content:center}
    .tile{
      width:var(--tile); height:var(--tile);
      border:2px solid var(--tile-border); border-radius:10px;
      display:grid; place-items:center; font-size:calc(var(--tile) * .38);
      font-weight:800; text-transform:uppercase; background:var(--tile-bg); color:#f8fafc;
      transition:transform .15s ease, background-color .2s ease, border-color .2s ease, box-shadow .2s ease;
      user-select:none;
      box-shadow:0 1px 0 rgba(255,255,255,.04) inset, 0 2px 8px rgba(0,0,0,.35);
    }
    .tile.filled{border-color:#60708a; animation:pop .09s ease}
    .tile.hinted{
      background: var(--hint-bg);
      border-color: var(--hint-border);
      box-shadow: 0 0 0 2px rgba(59,130,246,.25) inset, 0 2px 10px rgba(59,130,246,.25);
      color:#dbeafe;
    }
    .tile.correct{background:var(--correct); border-color:var(--correct); color:#05130a}
    .tile.present{background:var(--present); border-color:var(--present); color:#0d0c00}
    .tile.absent{background:var(--absent); border-color:var(--absent); color:#0b111a}
    .tile.flip{animation:flip .45s ease}
    @keyframes pop{0%,100%{transform:scale(1)}50%{transform:scale(1.08)}}
    @keyframes flip{0%{transform:rotateX(0)}50%{transform:rotateX(90deg)}100%{transform:rotateX(0)}}
    .keyboard-wrap{
      position:sticky; bottom:0; background:linear-gradient(180deg,#0e1623,#0a0f17);
      border-top:1px solid var(--border); padding:10px 8px; padding-bottom:calc(10px + env(safe-area-inset-bottom));
    }
    .keyboard{display:flex; flex-direction:column; gap:var(--k-gap)}
    .keyboard-row{display:flex; gap:var(--k-gap); justify-content:center}
    .key{
      background:var(--key-bg); border:1px solid var(--border); border-radius:10px;
      padding:10px; min-width:34px; min-height:44px;
      font-size:16px; font-weight:800; color:var(--key-text); text-transform:uppercase; cursor:pointer;
      user-select:none; touch-action:manipulation;
      box-shadow:0 2px 6px rgba(0,0,0,.35);
      transition:transform .06s ease, background-color .15s ease, border-color .15s ease;
    }
    .key:hover{ background:var(--key-bg-hover) }
    .key:active{ transform:scale(.97) }
    .key.correct{background:var(--correct); color:#05130a; border-color:#16a34a}
    .key.present{background:var(--present); color:#0d0c00; border-color:#ca8a04}
    .key.absent{background:var(--absent); color:#0b111a; border-color:#64748b}
    .stats{ text-align:center; color:var(--muted); font-size:.95rem; padding:8px 12px 2px }
    .message{
      position:fixed; top:16px; left:50%; transform:translateX(-50%);
      background:#0b1220; color:#e5e7eb; padding:10px 14px; border-radius:10px; font-weight:800;
      display:none; z-index:10; border:1px solid var(--border);
      box-shadow:0 10px 30px rgba(0,0,0,.5);
    }
    .message.show{display:block}
    .message.win{background:#052e13; border-color:#16a34a; color:#d1fae5}
    .message.lose{background:#2a0b0b; border-color:#b91c1c; color:#fee2e2}
    @media (max-width:420px){ h1{font-size:1.05rem} }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>WORDLE (A2–C1)</h1>
      <div class="controls">
        <label for="levelSel">ระดับ</label>
        <select id="levelSel" aria-label="เลือกระดับคำศัพท์">
          <option value="RANDOM">Random</option>
          <option value="A2">A2</option>
          <option value="B1">B1</option>
          <option value="B2">B2</option>
          <option value="C1" selected>C1</option>
        </select>
        <button id="btnHint">คำใบ้ (เหลือ 2)</button>
        <button id="btnNew" class="primary">เริ่มเกมใหม่</button>
      </div>
    </header>

    <div class="subtitle" id="subtitle">ทายคำภาษาอังกฤษ 5 ตัวอักษร • ระดับ: C1 • โอกาส 6 ครั้ง</div>

    <div class="content">
      <div class="game-board" id="gameBoard"></div>
      <div class="stats" id="stats">พิมพ์หรือแตะปุ่มเพื่อเริ่มเล่น</div>
    </div>

    <div class="keyboard-wrap">
      <div class="keyboard" id="keyboard"></div>
    </div>
  </div>

  <div class="message" id="message"></div>

  <script>
    const WORD_LENGTH = 5;
    const MAX_GUESSES = 6;

    // Hints
    const MAX_HINTS = 2;
    let hintsUsed = 0;
    let revealedPositions = Array(WORD_LENGTH).fill(false); // true = ช่องถูกใบ้/ล็อกแล้ว

    // STATE
    let LEVEL = localStorage.getItem('wordle-level') || 'C1';
    let lastPickedLevel = LEVEL;
    let targetWord = '';
    let currentGuess = Array(WORD_LENGTH).fill(''); // ใช้เป็น array เพื่อรองรับการล็อกตำแหน่งใบ้
    let currentRow = 0;
    let isAnimating = false;
    let gameOver = false;

    // dictionary (รวมทุกระดับ)
    let wordList = [];           // เฉลยตามระดับ
    let allowedSet = new Set();  // ตรวจคำรวมทุกระดับ
    let allowedReady = false;

    // DOM
    const $ = (s)=>document.querySelector(s);
    const gameBoard = $('#gameBoard');
    const keyboard = $('#keyboard');
    const message = $('#message');
    const stats = $('#stats');
    const subtitle = $('#subtitle');
    const levelSel = $('#levelSel');
    const container = document.querySelector('.container');
    const btnHint = $('#btnHint');

    const keyboardLayout = [
      ['Q','W','E','R','T','Y','U','I','O','P'],
      ['A','S','D','F','G','H','J','K','L'],
      ['ENTER','Z','X','C','V','B','N','M','BACK']
    ];

    levelSel.value = LEVEL;
    $('#btnNew').addEventListener('click', ()=> newGame(true));
    levelSel.addEventListener('change', async (e)=>{
      LEVEL = e.target.value;
      localStorage.setItem('wordle-level', LEVEL);
      await newGame(true);
    });
    btnHint.addEventListener('click', useHint);

    function setSubtitle(){
      const lvText = (LEVEL==='RANDOM') ? `RANDOM (รอบนี้: ${lastPickedLevel})` : LEVEL;
      subtitle.textContent = `ทายคำภาษาอังกฤษ ${WORD_LENGTH} ตัวอักษร • ระดับ: ${lvText} • โอกาส ${MAX_GUESSES} ครั้ง`;
    }

    function createBoard(){
      gameBoard.innerHTML = '';
      for (let r=0;r<MAX_GUESSES;r++){
        const row = document.createElement('div');
        row.className='row'; row.id=`row-${r}`;
        for (let c=0;c<WORD_LENGTH;c++){
          const tile = document.createElement('div');
          tile.className='tile'; tile.id=`tile-${r}-${c}`;
          row.appendChild(tile);
        }
        gameBoard.appendChild(row);
      }
      resizeTiles();
      // แสดงผลใบ้ (หากมี) บนแถวแรก
      resetCurrentGuessForRow();
      updateBoard();
    }

    function createKeyboard(){
      keyboard.innerHTML='';
      keyboardLayout.forEach(line=>{
        const row = document.createElement('div');
        row.className='keyboard-row';
        line.forEach(k=>{
          const btn = document.createElement('button');
          btn.className='key'; btn.textContent = (k==='BACK'?'⌫':k);
          btn.id=`key-${k}`;
          if (k==='ENTER' || k==='BACK') btn.classList.add('wide');
          btn.addEventListener('click', ()=> handleKey(k), {passive:true});
          row.appendChild(btn);
        });
        keyboard.appendChild(row);
      });
      layoutKeyboardSizes();
    }

    // ====== ปรับขนาด ======
    function resizeTiles(){
      const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8;
      const padH = 24;
      const boardWidth = container.clientWidth - padH;
      const t = Math.max(44, Math.min(62, Math.floor((boardWidth - (WORD_LENGTH-1)*gap)/WORD_LENGTH)));
      document.documentElement.style.setProperty('--tile', t+'px');
    }
    function layoutKeyboardSizes(){
      const kGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--k-gap')) || 6;
      const wrap = document.querySelector('.keyboard-wrap');
      const wrapW = wrap.clientWidth - 16;
      const rows = Array.from(keyboard.children);
      rows.forEach(row=>{
        const keys = Array.from(row.children);
        const unit = (btn)=> btn.classList.contains('wide') ? 1.6 : 1.0;
        const totalUnits = keys.reduce((s,btn)=> s + unit(btn), 0);
        const gaps = (keys.length - 1) * kGap;
        let keyW = Math.floor((wrapW - gaps) / totalUnits);
        keyW = Math.max(34, Math.min(92, keyW));
        keys.forEach(btn=>{
          const w = btn.classList.contains('wide') ? Math.floor(keyW*1.6) : keyW;
          btn.style.width = w+'px';
          btn.style.padding = Math.round(Math.max(10, Math.min(16, w*0.28))) + 'px';
        });
      });
    }

    // ====== พจนานุกรมรวม ======
    async function loadAllowedWords(){
      if (allowedReady) return;
      const files = ['a2','b1','b2','c1'].map(l => `words-${l}.json?v=${Date.now()}`);
      const fallbackDict = {
        A2: ["ABOUT","AFTER","AGAIN","APPLE","BEACH","BLACK","BREAD","BRING","BROWN","CHAIR","DRINK","EARLY","GREEN","HEART","HOUSE","LEARN","LIGHT","LOCAL","MONEY","MONTH","MOUTH","MUSIC","NIGHT","OTHER","PLANT","RIGHT","SMALL","SMILE","SOUTH","SPACE","SPEAK","START","STONE","STUDY","SWEET","TABLE","TEACH","THEIR","THERE","THESE","THING","THINK","THOSE","THREE","TODAY","UNDER","WATER","WHERE","WHICH","WORLD","WRITE"],
        B1: ["AWARE","BASIC","BEING","BREAK","CLEAR","DOUBT","ERROR","EXTRA","FAULT","FINAL","FOCUS","FORCE","FRAME","FRESH","FRONT","GIANT","GRADE","GRANT","GROUP","GUESS","HUMAN","IDEAL","IMAGE","INNER","ISSUE","LABEL","LARGE","LEAST","LEVEL","LIMIT","LOCAL","LOGIC","LUCKY","MAJOR","MATCH","MEDIA","METAL","MODEL","MOTOR","NOVEL","OCEAN","OFFER","OFTEN","PIECE","PILOT","PLACE","PLAIN","PLANT","PLATE","POINT","POWER","PRESS","PRICE","PRIME","PRINT","PRIOR","PRIZE","PROOF","PROVE","QUICK","QUIET","RADIO","RAISE","REACH","READY","REFER","RIGHT","RIVAL","RIVER","SCENE","SCORE","SENSE","SERVE","SHAPE","SHIFT","SHORT","SIGHT","SKILL","SMALL","SOLVE","SOUND","SPACE","SPEAK","SPEED","SPEND","STAFF","STAGE","STAND","STATE","STEEL","STICK","STILL","STONE","STORE","STORM","STORY","STYLE","SUPER","TABLE","TEETH","THEME","TITLE","TOUCH","TOUGH","TRACK","TRADE","TRAIN","TREND","TRIAL","TRUCK","TRUST","TRUTH","UNDER","UNION","UNTIL","URBAN","USUAL","VALUE","VISIT","VOCAL","VOICE","WATCH","WHOLE","WOMAN","YOUTH"],
        B2: ["ACUTE","ADAPT","ALIGN","ALIVE","AMEND","ARISE","AVERT","BLEND","BRISK","CRISP","DENSE","ELITE","EQUAL","EQUIP","ETHIC","FEIGN","FLAIR","FLUID","FRAIL","FRAUD","GRASP","GRAVE","HASTE","IMPLY","IRATE","LEERY","LITHE","LOFTY","LUCID","NOBLE","OCCUR","OPTIC","OVERT","PIQUE","PLUSH","POISE","PRIOR","PRONE","PROXY","QUOTA","RIGID","ROGUE","SEVER","SHREW","SLACK","SOLEMN","SPAWN","SPIRE","SPURN","STARK","STEEP","STERN","SUAVE","SUITE","TANGY","TENSE","TERSE","TIDAL","TORCH","TRITE","VALET","VAUNT","VIGOR","VOGUE","WIELD","YIELD"],
        C1: ["PITHY","LURID","BANAL","CAVIL","DEMUR","INANE","WRYLY","TERSE","TACIT","STOIC","TRITE","TEPID","VEXED","SLYLY","POSIT","GUILE","PRUDE","ROGUE","KNACK","PLAID","RIGOR","LITHE","LEERY","VIGOR","ICILY","DROLL","SURLY","RARER","TUMID","TURBO"]
      };
      try{
        const resps = await Promise.all(files.map(f => fetch(f, {cache:'no-store'}).catch(()=>null)));
        for (const r of resps){
          if (r && r.ok){
            const data = await r.json();
            const arr = Array.isArray(data) ? data : (data.words || []);
            arr.forEach(w=>{
              const s = String(w).toUpperCase();
              if (s.length===WORD_LENGTH && /^[A-Z]+$/.test(s)) allowedSet.add(s);
            });
          }
        }
        if (allowedSet.size===0){
          Object.values(fallbackDict).flat().forEach(w=>allowedSet.add(w));
        }
        allowedReady = true;
      }catch{
        Object.values(fallbackDict).flat().forEach(w=>allowedSet.add(w));
        allowedReady = true;
      }
    }

    // ====== เฉลยตามระดับ ======
    async function loadAnswerList(){
      let pickLevel = LEVEL;
      if (LEVEL === 'RANDOM') {
        const levels = ['A2','B1','B2','C1'];
        pickLevel = levels[Math.floor(Math.random()*levels.length)];
      }
      lastPickedLevel = pickLevel;

      const file = `words-${pickLevel.toLowerCase()}.json?v=${Date.now()}`;
      try{
        const res = await fetch(file, {cache:'no-store'});
        if (!res.ok) throw new Error('Cannot fetch list');
        const data = await res.json();
        const arr = Array.isArray(data) ? data : (data.words || []);
        wordList = arr.map(w=>String(w).toUpperCase())
                      .filter(w=>w.length===WORD_LENGTH && /^[A-Z]+$/.test(w));
        if (!wordList.length) throw new Error('Empty list');
      }catch{
        const fallback = {
          A2: ["ABOUT","AFTER","AGAIN","APPLE","BEACH","BLACK","BREAD","BRING","BROWN","CHAIR","DRINK","EARLY","GREEN","HEART","HOUSE","LEARN","LIGHT","LOCAL","MONEY","MONTH","MOUTH","MUSIC","NIGHT","OTHER","PLANT","RIGHT","SMALL","SMILE","SOUTH","SPACE","SPEAK","START","STONE","STUDY","SWEET","TABLE","TEACH","THEIR","THERE","THESE","THING","THINK","THOSE","THREE","TODAY","UNDER","WATER","WHERE","WHICH","WORLD","WRITE"],
          B1: ["AWARE","BASIC","BEING","BREAK","CLEAR","DOUBT","ERROR","EXTRA","FAULT","FINAL","FOCUS","FORCE","FRAME","FRESH","FRONT","GIANT","GRADE","GRANT","GROUP","GUESS","HUMAN","IDEAL","IMAGE","INNER","ISSUE","LABEL","LARGE","LEAST","LEVEL","LIMIT","LOCAL","LOGIC","LUCKY","MAJOR","MATCH","MEDIA","METAL","MODEL","MOTOR","NOVEL","OCEAN","OFFER","OFTEN","PIECE","PILOT","PLACE","PLAIN","PLANT","PLATE","POINT","POWER","PRESS","PRICE","PRIME","PRINT","PRIOR","PRIZE","PROOF","PROVE","QUICK","QUIET","RADIO","RAISE","REACH","READY","REFER","RIGHT","RIVAL","RIVER","SCENE","SCORE","SENSE","SERVE","SHAPE","SHIFT","SHORT","SIGHT","SKILL","SMALL","SOLVE","SOUND","SPACE","SPEAK","SPEED","SPEND","STAFF","STAGE","STAND","STATE","STEEL","STICK","STILL","STONE","STORE","STORM","STORY","STYLE","SUPER","TABLE","TEETH","THEME","TITLE","TOUCH","TOUGH","TRACK","TRADE","TRAIN","TREND","TRIAL","TRUCK","TRUST","TRUTH","UNDER","UNION","UNTIL","URBAN","USUAL","VALUE","VISIT","VOCAL","VOICE","WATCH","WHOLE","WOMAN","YOUTH"],
          B2: ["ACUTE","ADAPT","ALIGN","ALIVE","AMEND","ARISE","AVERT","BLEND","BRISK","CRISP","DENSE","ELITE","EQUAL","EQUIP","ETHIC","FEIGN","FLAIR","FLUID","FRAIL","FRAUD","GRASP","GRAVE","HASTE","IMPLY","IRATE","LEERY","LITHE","LOFTY","LUCID","NOBLE","OCCUR","OPTIC","OVERT","PIQUE","PLUSH","POISE","PRIOR","PRONE","PROXY","QUOTA","RIGID","ROGUE","SEVER","SHREW","SLACK","SOLEMN","SPAWN","SPIRE","SPURN","STARK","STEEP","STERN","SUAVE","SUITE","TANGY","TENSE","TERSE","TIDAL","TORCH","TRITE","VALET","VAUNT","VIGOR","VOGUE","WIELD","YIELD"],
          C1: ["PITHY","LURID","BANAL","CAVIL","DEMUR","INANE","WRYLY","TERSE","TACIT","STOIC","TRITE","TEPID","VEXED","SLYLY","POSIT","GUILE","PRUDE","ROGUE","KNACK","PLAID","RIGOR","LITHE","LEERY","VIGOR","ICILY","DROLL","SURLY","RARER","TUMID","TURBO"]
        };
        wordList = (fallback[pickLevel]||fallback.C1).filter(w=>w.length===WORD_LENGTH);
      }

      targetWord = wordList[Math.floor(Math.random()*wordList.length)];
      console.log('คำที่ต้องทาย:', targetWord, '(ระดับเฉลย:', lastPickedLevel, ')');
    }

    // ====== HINT SYSTEM ======
    function updateHintButton(){
      btnHint.textContent = `คำใบ้ (เหลือ ${MAX_HINTS - hintsUsed})`;
      btnHint.disabled = (hintsUsed >= MAX_HINTS) || gameOver;
      btnHint.style.opacity = btnHint.disabled ? 0.6 : 1;
      btnHint.style.cursor = btnHint.disabled ? 'not-allowed' : 'pointer';
    }

    function useHint(){
      if (gameOver) return;
      if (hintsUsed >= MAX_HINTS){
        showMessage('ใช้คำใบ้ครบแล้ว');
        return;
      }
      // เลือกตำแหน่งที่ยังไม่ถูกใบ้
      const candidates = [];
      for (let i=0;i<WORD_LENGTH;i++){
        if (!revealedPositions[i]) candidates.push(i);
      }
      if (candidates.length===0){
        showMessage('เปิดครบทุกตำแหน่งแล้ว');
        return;
      }
      const idx = candidates[Math.floor(Math.random()*candidates.length)];
      revealedPositions[idx] = true;
      hintsUsed++;
      // ใส่ตัวอักษรถูกต้องในแถวปัจจุบัน + ล็อก
      currentGuess[idx] = targetWord[idx];
      updateBoard();
      // ทำให้ไทล์ที่ใบ้มีสไตล์พิเศษ
      const tile = document.getElementById(`tile-${currentRow}-${idx}`);
      tile.classList.add('hinted','filled');
      showMessage(`ใบ้: ตัวที่ ${idx+1} คือ "${targetWord[idx]}"`);
      updateHintButton();
    }

    function resetCurrentGuessForRow(){
      currentGuess = Array(WORD_LENGTH).fill('');
      for (let i=0;i<WORD_LENGTH;i++){
        if (revealedPositions[i]){
          currentGuess[i] = targetWord[i];
        }
      }
    }

    // ====== INPUT ======
    function handleKey(key){
      if (gameOver || isAnimating) return;
      if (key==='BACK'){
        // ลบจากขวาสุดที่ "ไม่ใช่ช่องใบ้" และมีตัวอักษร
        for (let i=WORD_LENGTH-1;i>=0;i--){
          if (!revealedPositions[i] && currentGuess[i]){
            currentGuess[i] = '';
            break;
          }
        }
        updateBoard();
        return;
      }
      if (key==='ENTER'){
        // ต้องกรอกครบทุกช่อง (รวมช่องใบ้)
        if (!currentGuess.every(ch => ch && ch.length===1)){
          showMessage(`กรุณากรอกคำให้ครบ ${WORD_LENGTH} ตัวอักษร`);
          return;
        }
        const guessStr = currentGuess.join('');
        if (allowedReady && !allowedSet.has(guessStr)){
          showMessage('คำนี้ไม่อยู่ในพจนานุกรม รวมทุกระดับ');
          return;
        }
        checkGuess();
        return;
      }
      if (key.length===1 && key>='A' && key<='Z'){
        // ใส่ลง "ช่องแรกสุด" ที่ยังว่างและไม่ใช่ช่องใบ้
        for (let i=0;i<WORD_LENGTH;i++){
          if (!revealedPositions[i] && !currentGuess[i]){
            currentGuess[i] = key;
            break;
          }
        }
        updateBoard();
      }
    }

    function updateBoard(){
      for (let i=0;i<WORD_LENGTH;i++){
        const tile = document.getElementById(`tile-${currentRow}-${i}`);
        tile.textContent = currentGuess[i] || '';
        tile.classList.toggle('filled', !!currentGuess[i]);
        tile.classList.toggle('hinted', revealedPositions[i] && !!currentGuess[i]);
      }
    }

    // ====== RESULT ======
    function checkGuess(){
      const guess = currentGuess.join('');
      const target = targetWord;

      const counts = {};
      for (const ch of target) counts[ch] = (counts[ch]||0)+1;
      const results = Array(WORD_LENGTH).fill('absent');

      // correct
      for (let i=0;i<WORD_LENGTH;i++){
        if (guess[i]===target[i]){
          results[i]='correct'; counts[guess[i]]--;
        }
      }
      // present
      for (let i=0;i<WORD_LENGTH;i++){
        if (results[i]==='correct') continue;
        const ch = guess[i];
        if (counts[ch]>0){ results[i]='present'; counts[ch]--; }
      }

      isAnimating = true;
      for (let i=0;i<WORD_LENGTH;i++){
        const tile = document.getElementById(`tile-${currentRow}-${i}`);
        const letter = guess[i];
        setTimeout(()=> tile.classList.add('flip'), i*180);
        setTimeout(()=>{
          tile.classList.remove('flip','hinted'); // หลังเฉลย ลบสถานะ hinted ในแถวนี้
          tile.classList.add(results[i]);
          updateKeyColor(letter, results[i]);
        }, i*180 + 220);
      }

      const doneAt = WORD_LENGTH*180 + 260;
      setTimeout(()=>{
        if (guess===target){
          gameOver = true;
          showMessage('🎉 เก่งมากครับ!! ครูจ๋าถูกแล้ว','win');
          updateStats(`คุณทายถูกใน ${currentRow+1} ครั้ง`);
        } else if (currentRow===MAX_GUESSES-1){
          gameOver = true;
          showMessage(`คำที่ถูกต้องคือ: ${target}`,'lose');
          updateStats('ลองใหม่อีกครั้ง!');
        } else {
          currentRow++;
          resetCurrentGuessForRow(); // เติมช่องใบ้ในแถวใหม่ด้วย
          // อัปเดต UI แถวใหม่ (แถวเก่าจะคงสีผลลัพธ์ไว้)
          updateBoard();
        }
        isAnimating = false;
      }, doneAt);
    }

    function updateKeyColor(letter, result){
      const key = document.getElementById(`key-${letter}`);
      if (!key) return;
      const priority = {absent:1, present:2, correct:3};
      const cur = priority[key.dataset.state] || 0;
      const nxt = priority[result] || 0;
      if (nxt>cur){
        key.dataset.state = result;
        key.className = `key ${result}${key.classList.contains('wide')?' wide':''}`;
      }
    }

    // ====== UX: Toast/Stats ======
    function showMessage(text, type=''){
      message.textContent = text;
      message.className = `message show ${type}`;
      clearTimeout(showMessage._t);
      showMessage._t = setTimeout(()=> message.classList.remove('show'), 2400);
    }
    function updateStats(text){ stats.textContent = text; }

    // ====== GAME FLOW ======
    async function newGame(){
      // reset states
      currentGuess = Array(WORD_LENGTH).fill('');
      currentRow = 0; gameOver=false; isAnimating=false;
      hintsUsed = 0;
      revealedPositions = Array(WORD_LENGTH).fill(false);
      updateHintButton();

      await Promise.all([loadAllowedWords(), loadAnswerList()]);
      setSubtitle();
      createBoard();
      createKeyboard();
      updateStats('พิมพ์หรือแตะปุ่มเพื่อเริ่มเล่น');
    }

    // ปรับขนาดเมื่อหน้าจอเปลี่ยน/หมุน
    const ro = new ResizeObserver(()=>{ resizeTiles(); layoutKeyboardSizes(); });
    ro.observe(document.body);
    window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ resizeTiles(); layoutKeyboardSizes(); }, 250); });

    // คีย์บอร์ดจริง
    document.addEventListener('keydown',(e)=>{
      const k = e.key.toUpperCase();
      if (k==='BACKSPACE') handleKey('BACK');
      else if (k==='ENTER') handleKey('ENTER');
      else if (k.length===1 && k>='A' && k<='Z') handleKey(k);
    }, {passive:true});

    // boot
    newGame();
  </script>
</body>
</html>
